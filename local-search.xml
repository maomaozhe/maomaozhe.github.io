<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>springcloud概览</title>
    <link href="/2024/10/10/springcloud%E6%A6%82%E8%A7%88/"/>
    <url>/2024/10/10/springcloud%E6%A6%82%E8%A7%88/</url>
    
    <content type="html"><![CDATA[<h3 id="springcloud-的基础组成"><a href="#springcloud-的基础组成" class="headerlink" title="springcloud 的基础组成"></a>springcloud 的基础组成</h3><img src="/2024/10/10/springcloud%E6%A6%82%E8%A7%88/xmind-springcloud.png" class=""> <img src="/2024/10/10/springcloud%E6%A6%82%E8%A7%88/xmind-springcloud.png" class="" title="xmind-springcloud"><p>这是CHATGPT 的 路径</p><h3 id="1-Spring-Boot-基础"><a href="#1-Spring-Boot-基础" class="headerlink" title="1. Spring Boot 基础"></a>1. <strong>Spring Boot 基础</strong></h3><ul><li>Spring Cloud 是基于 Spring Boot 的，因此要确保你熟练掌握 Spring Boot 的基础知识，包括依赖管理、Spring Boot Starter、自动配置、RESTful API 开发、Spring Data 等内容。</li></ul><h3 id="2-微服务架构概念"><a href="#2-微服务架构概念" class="headerlink" title="2. 微服务架构概念"></a>2. <strong>微服务架构概念</strong></h3><ul><li>了解微服务的基本概念和优势，特别是与单体架构的区别。重点包括：<ul><li><strong>服务的独立部署和扩展</strong>：每个服务独立开发、部署和扩展。</li><li><strong>服务的通信方式</strong>：通过 HTTP REST 或消息队列进行通信。</li><li><strong>服务的分布式管理</strong>：如何管理多个微服务之间的依赖和协作。</li></ul></li></ul><h3 id="3-服务注册与发现"><a href="#3-服务注册与发现" class="headerlink" title="3. 服务注册与发现"></a>3. <strong>服务注册与发现</strong></h3><ul><li><strong>Eureka</strong>：Spring Cloud 提供的服务注册和发现工具，Eureka Server 允许每个微服务向其注册，并且可以让服务找到彼此。</li><li><strong>Consul &#x2F; Zookeeper</strong>：除了 Eureka，Spring Cloud 还支持 Consul 和 Zookeeper 作为服务注册与发现工具。</li><li>Nacos 是<strong>主流</strong></li></ul><h3 id="4-负载均衡"><a href="#4-负载均衡" class="headerlink" title="4. 负载均衡"></a>4. <strong>负载均衡</strong></h3><ul><li><strong>Ribbon</strong>：Spring Cloud 提供客户端负载均衡的解决方案，通过 Ribbon，微服务调用可以实现负载均衡。</li><li><strong>Spring Cloud LoadBalancer</strong>：一种更现代的负载均衡工具，逐渐替代 Ribbon。</li></ul><h3 id="5-API-网关"><a href="#5-API-网关" class="headerlink" title="5. API 网关"></a>5. <strong>API 网关</strong></h3><ul><li><strong>Spring Cloud Gateway</strong>：用于构建 API 网关的解决方案，允许将多个微服务暴露在统一的 API 接口下，并支持路由、过滤器、安全性和限流等功能。</li><li><strong>Zuul</strong>：Spring Cloud 旧版本中使用的 API 网关，逐渐被 Gateway 取代。</li></ul><h3 id="6-配置管理"><a href="#6-配置管理" class="headerlink" title="6. 配置管理"></a>6. <strong>配置管理</strong></h3><ul><li><strong>Spring Cloud Config</strong>：实现配置的集中管理和分布式配置更新，支持从 Git 仓库或本地文件中读取配置文件，允许动态更新微服务配置。</li></ul><h3 id="7-断路器（熔断机制）"><a href="#7-断路器（熔断机制）" class="headerlink" title="7. 断路器（熔断机制）"></a>7. <strong>断路器（熔断机制）</strong></h3><ul><li><strong>Hystrix</strong>：用于处理微服务之间的失败，防止服务调用链中的级联失败，能够实现服务的降级与熔断。</li><li><strong>Resilience4j</strong>：Hystrix 的替代品，更加轻量，且与 Spring Boot 的兼容性更强。</li></ul><h3 id="8-分布式追踪"><a href="#8-分布式追踪" class="headerlink" title="8. 分布式追踪"></a>8. <strong>分布式追踪</strong></h3><ul><li><strong>Sleuth</strong> 和 <strong>Zipkin</strong>：Sleuth 可以为微服务调用链中的请求加上跟踪 ID，Zipkin 可以收集、展示这些追踪数据，帮助你了解系统的性能瓶颈和问题所在。</li></ul><h3 id="9-消息驱动的微服务"><a href="#9-消息驱动的微服务" class="headerlink" title="9. 消息驱动的微服务"></a>9. <strong>消息驱动的微服务</strong></h3><ul><li><strong>Spring Cloud Stream</strong>：实现基于消息驱动的微服务通信，支持 Kafka 和 RabbitMQ 等消息中间件。</li></ul><h3 id="10-分布式事务"><a href="#10-分布式事务" class="headerlink" title="10. 分布式事务"></a>10. <strong>分布式事务</strong></h3><ul><li><strong>Spring Cloud Sleuth</strong>、<strong>Saga</strong>、<strong>TCC</strong>等模式用于实现分布式系统中的一致性问题和分布式事务处理。</li></ul><h3 id="11-监控与运维"><a href="#11-监控与运维" class="headerlink" title="11. 监控与运维"></a>11. <strong>监控与运维</strong></h3><ul><li><strong>Spring Boot Actuator</strong>：监控和管理生产环境中的应用，提供健康检查、指标监控等功能。</li><li><strong>Prometheus &#x2F; Grafana</strong>：用于收集和展示微服务的运行指标。</li></ul><h3 id="12-安全"><a href="#12-安全" class="headerlink" title="12. 安全"></a>12. <strong>安全</strong></h3><ul><li><strong>Spring Security + OAuth2</strong>：处理微服务间的认证与授权问题。Spring Cloud Security 可以实现 OAuth2 的认证授权，保护微服务。</li></ul><p>黑马的ppt梳理了关系 以及学习的路线</p> <img src="/2024/10/10/springcloud%E6%A6%82%E8%A7%88/xuexi.png" class=""> ]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>微服务</tag>
      
      <tag>技术概览</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>date</title>
    <link href="/2024/10/06/date/"/>
    <url>/2024/10/06/date/</url>
    
    <content type="html"><![CDATA[<p>焱焱来找我了，确定关系的第二天来找我，在我和同学的小酒馆把我接走了，哈哈，带着鲜花和羽毛球</p><p>她真的很特别</p><p>y</p><p>值得一提的是，今天下午有一点小摩擦，她在说她的比较严肃的事情的时候我回复的显得有点不重视甚至是敷衍了，所以emmmm,其实这个我还是应该引起重视的，看似是我在忙仍然要回信息，但其实这个观点是愚蠢的哈哈哈哈</p>]]></content>
    
    
    
    <tags>
      
      <tag>恋爱</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring/springboot/bean/IOC简单梳理</title>
    <link href="/2024/09/28/Spring-springboot-bean-IOC%E7%AE%80%E5%8D%95%E6%A2%B3%E7%90%86/"/>
    <url>/2024/09/28/Spring-springboot-bean-IOC%E7%AE%80%E5%8D%95%E6%A2%B3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>Spring Boot 是基于 <strong>Spring 框架</strong> 的简化版，旨在减少 Spring 应用的配置复杂度，提供了许多开箱即用的功能。它主要依赖于 <strong>Spring</strong> 及其核心概念，比如 <strong>Bean</strong> 和 **IOC (Inversion of Control，控制反转)**。要理解 Spring Boot 的核心及其简化开发的作用，必须先掌握这些基本概念以及它们之间的关系。</p><h3 id="一、Spring-Boot-概述"><a href="#一、Spring-Boot-概述" class="headerlink" title="一、Spring Boot 概述"></a>一、Spring Boot 概述</h3><p><strong>Spring Boot</strong> 是 Spring 框架的一个子项目，目的是简化 Spring 应用的开发过程。它提供了一系列的自动配置功能，使开发者可以专注于业务逻辑，而无需处理繁琐的配置工作。其核心特性包括：</p><ol><li><strong>自动配置（Auto-Configuration）</strong>：Spring Boot 能够自动根据类路径中存在的类、定义的 Bean 和配置文件，推测应用的需求并自动配置 Spring 应用。</li><li><strong>嵌入式服务器</strong>：Spring Boot 提供了嵌入式的 Tomcat、Jetty 等服务器，使得应用无需手动部署到外部服务器上，应用可以直接运行为一个独立的 Java 应用。</li><li><strong>简化的 Maven&#x2F;Gradle 配置</strong>：Spring Boot 提供了 <strong>starter</strong> 依赖，通过一个依赖可以集成多个功能，减少了手动配置依赖项的复杂性。</li><li><strong>Actuator</strong>：Spring Boot 的 Actuator 提供了对应用运行状态的监控功能，包括健康检查、指标、日志等。</li></ol><p>Spring Boot 的核心思想就是通过自动配置和约定大于配置的理念，使开发者能够快速上手开发，无需深度了解 Spring 的复杂机制。</p><h3 id="二、Bean-与-Spring-容器"><a href="#二、Bean-与-Spring-容器" class="headerlink" title="二、Bean 与 Spring 容器"></a>二、Bean 与 Spring 容器</h3><p><strong>Bean</strong> 是 Spring 的核心概念之一，指的是由 Spring 容器管理的对象。传统 Java 开发中，对象是通过手动实例化并管理的，而在 Spring 中，Bean 是通过 <strong>Spring 容器</strong> 进行创建和管理的。所有的业务逻辑组件，比如 <strong>Service</strong>、<strong>Repository</strong>、<strong>Controller</strong> 等，都可以被声明为 Bean。</p><h4 id="1-什么是-Bean？"><a href="#1-什么是-Bean？" class="headerlink" title="1. 什么是 Bean？"></a>1. 什么是 Bean？</h4><p>Bean 是 Spring 管理的对象，它们通常通过注解 <code>@Component</code>、<code>@Service</code>、<code>@Repository</code>@Repository<code>、</code>@Controller&#96; 等声明，或者通过 XML 文件配置。在应用运行时，Spring 会根据这些注解或配置，自动将这些类实例化并注入到需要的地方。这个过程称为 <strong>依赖注入（Dependency Injection）</strong>。</p><p>常用的 Bean 定义方式包括：</p><ul><li><strong>基于注解的定义</strong>：在类上加上注解，如 <code>@Component</code>，让 Spring 自动管理该类。</li><li><strong>基于 XML 文件的定义</strong>：通过 Spring 配置文件（XML）明确声明哪些类应该作为 Bean。</li></ul><h4 id="2-Bean-的生命周期"><a href="#2-Bean-的生命周期" class="headerlink" title="2. Bean 的生命周期"></a>2. Bean 的生命周期</h4><p>Bean 的生命周期由 Spring 容器管理，主要包括以下几个阶段：</p><ul><li><strong>实例化</strong>：Spring 容器会根据配置或注解创建 Bean 的实例。</li><li><strong>属性注入</strong>：Spring 容器会注入依赖的其他 Bean。</li><li><strong>初始化</strong>：如果有配置初始化方法，Spring 容器会调用该方法。</li><li><strong>销毁</strong>：当容器关闭时，Spring 容器会调用销毁方法，释放资源。</li></ul><h3 id="三、IOC（Inversion-of-Control，控制反转）"><a href="#三、IOC（Inversion-of-Control，控制反转）" class="headerlink" title="三、IOC（Inversion of Control，控制反转）"></a>三、IOC（Inversion of Control，控制反转）</h3><p><strong>IOC（控制反转）</strong> 是 Spring 的核心理念之一。它指的是将对象创建、管理、依赖注入等操作的控制权从开发者手中“反转”到 Spring 容器中。</p><h4 id="1-IOC-的工作原理"><a href="#1-IOC-的工作原理" class="headerlink" title="1. IOC 的工作原理"></a>1. IOC 的工作原理</h4><p>传统的面向对象编程中，开发者需要自己创建对象及其依赖，比如在构造函数或方法中实例化对象。而在 Spring 中，开发者只需要声明需要的对象及依赖关系，Spring 容器会负责对象的创建和依赖的注入。</p><p>IOC 的核心机制是 <strong>依赖注入</strong>（Dependency Injection），有三种常见的依赖注入方式：</p><ul><li><strong>构造器注入</strong>：通过类的构造方法注入依赖对象。</li><li><strong>Setter 方法注入</strong>：通过 Setter 方法注入依赖对象。</li><li><strong>字段注入</strong>：通过注解 <code>@Autowired</code> 直接在字段上注入依赖对象。</li></ul><h4 id="2-IOC-的优势"><a href="#2-IOC-的优势" class="headerlink" title="2. IOC 的优势"></a>2. IOC 的优势</h4><ul><li><strong>解耦</strong>：开发者只需专注于业务逻辑，而不用关心对象的创建和生命周期管理。不同组件间的依赖关系由 Spring 管理，降低了模块之间的耦合度。</li><li><strong>可测试性</strong>：由于依赖关系被外部注入，开发者可以很方便地通过模拟对象进行单元测试。</li></ul><h3 id="四、Bean-与-IOC-的关系"><a href="#四、Bean-与-IOC-的关系" class="headerlink" title="四、Bean 与 IOC 的关系"></a>四、Bean 与 IOC 的关系</h3><ul><li><strong>IOC 容器管理 Bean</strong>：Spring 容器是 IOC 容器，负责管理 Bean 的创建、初始化和销毁过程。Spring 容器会根据 Bean 的配置或注解自动创建它们，并注入到需要它们的地方。</li><li><strong>Bean 是 IOC 的核心对象</strong>：所有的业务逻辑组件在 Spring 中被称为 Bean，所有 Bean 的创建、销毁和依赖注入都通过 IOC 来完成。</li></ul><h3 id="五、Spring-Boot-的核心"><a href="#五、Spring-Boot-的核心" class="headerlink" title="五、Spring Boot 的核心"></a>五、Spring Boot 的核心</h3><p>Spring Boot 的核心是基于 Spring 的 IOC 和依赖注入机制进行应用的快速开发。它通过简化配置的方式，将 Spring 框架中的核心机制（如 IOC、AOP、数据访问等）封装成更加易于使用的形式。</p><h4 id="1-自动配置"><a href="#1-自动配置" class="headerlink" title="1. 自动配置"></a>1. 自动配置</h4><p>Spring Boot 的自动配置功能是它的一个关键特点。它根据类路径中的依赖项自动配置 Spring 的 Bean，减少了手动配置的复杂度。例如，若项目中包含了 <code>spring-boot-starter-data-jpa</code> 依赖，Spring Boot 会自动配置 JPA 相关的 Bean（如 <code>EntityManager</code> 等），无需手动指定。</p><h4 id="2-Starter-模块"><a href="#2-Starter-模块" class="headerlink" title="2. Starter 模块"></a>2. Starter 模块</h4><p>Spring Boot 提供了许多 <strong>starter</strong> 模块，用于快速集成常用的功能。例如：</p><ul><li><code>spring-boot-starter-web</code>：用于开发基于 Spring MVC 的 Web 应用。</li><li><code>spring-boot-starter-data-jpa</code>：用于开发基于 JPA 的数据访问应用。</li></ul><p>这些 starter 模块通过 Maven 或 Gradle 进行依赖管理，并自动引入相关的配置和依赖。</p><h4 id="3-嵌入式服务器"><a href="#3-嵌入式服务器" class="headerlink" title="3. 嵌入式服务器"></a>3. 嵌入式服务器</h4><p>Spring Boot 提供了嵌入式的 Tomcat、Jetty 等服务器，应用可以直接作为一个 Java 应用运行，而无需外部部署到容器中。这进一步简化了开发和部署的流程。</p><h3 id="六、Spring-Boot、Bean-与-IOC-的关系与作用"><a href="#六、Spring-Boot、Bean-与-IOC-的关系与作用" class="headerlink" title="六、Spring Boot、Bean 与 IOC 的关系与作用"></a>六、Spring Boot、Bean 与 IOC 的关系与作用</h3><ul><li><strong>Spring Boot 自动化 IOC</strong>：Spring Boot 使用 Spring 的 IOC 容器来管理 Bean，开发者不需要显式配置 Bean，Spring Boot 会根据约定自动配置和管理它们。</li><li><strong>Bean 的自动注册</strong>：Spring Boot 会自动扫描类路径中的组件（带有 <code>@Component</code>、<code>@Service</code>、<code>@Controller</code> 等注解的类），并将它们注册为 Bean。</li><li><strong>自动配置与 IOC 的结合</strong>：通过自动配置，Spring Boot 能够自动创建和注入常用的 Bean，如数据库连接池、事务管理器等。IOC 机制使得这些自动配置的 Bean 可以被全局使用。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Spring Boot 是基于 Spring 框架的增强，它简化了 Spring 应用的开发，依赖于 Spring 的核心机制（如 IOC 和 Bean）。Spring Boot 的核心在于自动配置，它结合了 IOC 容器的能力，自动管理 Bean 和依赖，开发者无需手动配置依赖和 Bean 管理，大幅提升了开发效率。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>要通过简单的例子来体现 <strong>Spring Boot</strong>、<strong>Bean</strong> 和 <strong>IOC</strong> 之间的关系，可以考虑创建一个简单的 Spring Boot Web 应用，通过自动化配置和依赖注入，展示 Spring Boot 如何自动管理 Bean 以及控制反转（IOC）的工作原理。</p><h4 id="一、项目结构"><a href="#一、项目结构" class="headerlink" title="一、项目结构"></a>一、项目结构</h4><p>首先，我们创建一个简单的 Spring Boot 应用。目录结构如下：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs maxima">css复制代码<span class="hljs-built_in">demo</span>/<br> └── src/<br>     └── main/<br>         └── java/<br>             └── com/<span class="hljs-built_in">example</span>/<span class="hljs-built_in">demo</span>/<br>                 ├── DemoApplication.java<br>                 ├── controller/<br>                 │   └── HelloController.java<br>                 └── service/<br>                     └── HelloService.java<br></code></pre></td></tr></table></figure><h4 id="二、代码实现"><a href="#二、代码实现" class="headerlink" title="二、代码实现"></a>二、代码实现</h4><h5 id="1-创建-Spring-Boot-启动类"><a href="#1-创建-Spring-Boot-启动类" class="headerlink" title="1. 创建 Spring Boot 启动类"></a>1. 创建 Spring Boot 启动类</h5><p>这是 Spring Boot 应用的入口。<code>DemoApplication</code> 类包含 <code>main</code> 方法，并通过注解 <code>@SpringBootApplication</code> 启动 Spring Boot 应用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">java复制代码<span class="hljs-keyword">package</span> com.example.demo;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(DemoApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>@SpringBootApplication</code> 是一个组合注解，包含了 <code>@Configuration</code>、<code>@EnableAutoConfiguration</code> 和 <code>@ComponentScan</code>，它会自动扫描当前包及其子包中的组件，自动配置应用并注册 Bean。</li></ul><h5 id="2-创建服务类-HelloService"><a href="#2-创建服务类-HelloService" class="headerlink" title="2. 创建服务类 HelloService"></a>2. 创建服务类 <code>HelloService</code></h5><p>这是一个简单的服务类，带有 <code>@Service</code> 注解。它表示这是一个由 Spring 管理的 Bean，通过 IOC 容器可以将它注入到其他组件中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">java复制代码<span class="hljs-keyword">package</span> com.example.demo.service;<br><br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloService</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getGreeting</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, Spring Boot!&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>@Service</code> 表示该类是一个服务类，它会自动被 Spring 扫描并注册为 Bean。</li></ul><h5 id="3-创建控制器类-HelloController"><a href="#3-创建控制器类-HelloController" class="headerlink" title="3. 创建控制器类 HelloController"></a>3. 创建控制器类 <code>HelloController</code></h5><p>这是一个 Spring MVC 控制器，接收 HTTP 请求并调用 <code>HelloService</code> 来生成响应内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java">java复制代码<span class="hljs-keyword">package</span> com.example.demo.controller;<br><br><span class="hljs-keyword">import</span> com.example.demo.service.HelloService;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloController</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> HelloService helloService;<br><br>    <span class="hljs-comment">// 使用构造函数注入 HelloService</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">HelloController</span><span class="hljs-params">(HelloService helloService)</span> &#123;<br>        <span class="hljs-built_in">this</span>.helloService = helloService;<br>    &#125;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/hello&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> helloService.getGreeting();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>@RestController</code> 注解表示这是一个 REST 风格的控制器，处理 HTTP 请求并返回 JSON 或纯文本。</li><li><code>@GetMapping(&quot;/hello&quot;)</code> 将 <code>/hello</code> 路径的 GET 请求映射到 <code>sayHello</code> 方法上。</li><li><code>@Autowired</code> 注解表示 <strong>依赖注入</strong>，Spring 会通过 IOC 容器将 <code>HelloService</code> 的实例自动注入到 <code>HelloController</code> 中。</li></ul><h3 id="三、运行应用"><a href="#三、运行应用" class="headerlink" title="三、运行应用"></a>三、运行应用</h3><p>通过 <code>mvn spring-boot:run</code> 或者直接运行 <code>DemoApplication</code> 中的 <code>main</code> 方法，启动 Spring Boot 应用。</p><p>启动后，打开浏览器访问 <code>http://localhost:8080/hello</code>，你会看到以下响应：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">复制代码<br><span class="hljs-built_in">Hello,</span> Spring Boot!<br></code></pre></td></tr></table></figure><h3 id="四、分析"><a href="#四、分析" class="headerlink" title="四、分析"></a>四、分析</h3><p>通过这个简单的例子，我们可以看到 Spring Boot 和 IOC 的结合是如何工作的：</p><ol><li><strong>自动配置</strong>：<ul><li>通过 <code>@SpringBootApplication</code> 注解，Spring Boot 自动扫描项目的包路径，并自动配置必要的组件。</li></ul></li><li><strong>Bean 的管理</strong>：<ul><li><code>HelloService</code> 被 <code>@Service</code> 标记为一个 Bean，Spring IOC 容器会自动创建该类的实例并管理其生命周期。</li></ul></li><li><strong>IOC 和依赖注入</strong>：<ul><li>在 <code>HelloController</code> 中，使用 <code>@Autowired</code> 将 <code>HelloService</code> 注入。这个过程称为控制反转（IOC），即由 Spring 容器来控制 <code>HelloService</code> 的创建及注入，而非手动创建和管理。</li></ul></li><li><strong>简化配置</strong>：<ul><li>在这个示例中，Spring Boot 通过自动配置的方式，省去了配置文件和手动 Bean 注册的步骤，使得开发者能够更专注于业务逻辑。</li></ul></li></ol><h3 id="五、扩展"><a href="#五、扩展" class="headerlink" title="五、扩展"></a>五、扩展</h3><p>Spring Boot 提供了更强大的功能和扩展能力。在这个例子中，你可以通过以下方式进一步扩展：</p><ul><li><strong>使用外部配置文件</strong>：可以在 <code>application.properties</code> 或 <code>application.yml</code> 文件中添加配置项来改变默认行为。</li><li><strong>数据库访问</strong>：通过添加 <code>spring-boot-starter-data-jpa</code>，你可以轻松实现数据库访问功能，而无需手动配置数据源或事务管理。</li><li><strong>异常处理</strong>：通过 <code>@ControllerAdvice</code> 和 <code>@ExceptionHandler</code> 来实现全局异常处理，这也是 Spring Boot 自动化功能的一部分。</li></ul><p>这个简单的例子展示了 Spring Boot 如何使用 Bean 和 IOC 来简化应用开发，同时保持高度的灵活性。</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>技术概念关系梳理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字节青训营</title>
    <link href="/2024/09/28/%E5%AD%97%E8%8A%82%E9%9D%92%E8%AE%AD%E8%90%A5/"/>
    <url>/2024/09/28/%E5%AD%97%E8%8A%82%E9%9D%92%E8%AE%AD%E8%90%A5/</url>
    
    <content type="html"><![CDATA[<p>字节的青训营开始了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iotream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;555&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>test</title>
    <link href="/2024/09/26/test/"/>
    <url>/2024/09/26/test/</url>
    
    <content type="html"><![CDATA[<h2 id="这是一篇测试文章"><a href="#这是一篇测试文章" class="headerlink" title="这是一篇测试文章"></a>这是一篇测试文章</h2><h3 id="这是一篇测试文章-1"><a href="#这是一篇测试文章-1" class="headerlink" title="这是一篇测试文章"></a>这是一篇测试文章</h3><h4 id="这是一篇测试文章-2"><a href="#这是一篇测试文章-2" class="headerlink" title="这是一篇测试文章"></a>这是一篇测试文章</h4><p> 测试图片：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmake">&#123;% asset_img <span class="hljs-keyword">test</span>.jpg 图片引用方法一 %&#125; <br><br>![图片引用方法三](<span class="hljs-keyword">test</span>\<span class="hljs-keyword">test</span>.jpg)<br>[图片引用方法三](<span class="hljs-keyword">test</span>.jpg)<br>似乎要这样，hexo会把他们整合<br></code></pre></td></tr></table></figure><p><img src="/test.jpg" alt="图片引用方法三"></p><img src="/2024/09/26/test/test.jpg" class="" title="图片引用方法一"> <p>bug:</p><p>windows中路径是 <code>test\test.jpg</code> 不是<del>png</del> hhh 以及<u>注意文件的后缀</u>哈哈哈哈</p><p>debug 时候突然灵光，md中复制的时候，不是会出现图片路径嘛，比对一下</p><p>还有就是，看到这张测试图片，百感交集哈哈哈，最近综测看着这些材料…..</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/09/26/hello-world/"/>
    <url>/2024/09/26/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
